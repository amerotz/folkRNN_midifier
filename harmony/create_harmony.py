import numpy as np
import random
import sys

filename = sys.argv[1]
melody_w = float(sys.argv[2])

# retrieve info from file

lines = ''
with open(filename, 'r') as f:
    lines = f.readlines()

key_mode = lines[0].split(' ')
key = int(key_mode[0])
mode = key_mode[1]
melody = ''.join(lines[2:]).split('|')

# build the matrix

note_matrix = np.array([1, 0, 0, 1, 0, 1, 0], dtype=float)

'''
transition_matrix = np.array([
    [0, 1, 1, 1, 1, 1, 0],
    [0, 0, 0, 0, 1, 0, 1],
    [0, 0, 0, 1, 0, 0, 0],
    [1, 1, 0, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 1, 0],
    [0, 1, 0, 1, 1, 0, 0],
    [1, 0, 0, 0, 0, 0, 0]
], dtype=float) + np.eye(7)

for line in transition_matrix:
    num = line.sum()
    if num != 0:
        line /= num
'''

# start generation
chords = range(7)

# get chord outlined by the melody
# each note gives can equally be a tonic, a third or a fifth
# add points to each possible chord for each notes
# sample random beween first 3 argmax
def getState(bar):
    note_state = np.zeros(7)
    for note in bar:
        note = int(note)
        note_state += np.roll(note_matrix, note)
    # vvv not really needed since it's just argmax
    #note_state /= note_state.sum()
    return random.choice(np.argwhere(note_state == np.amax(note_state)).flatten().tolist())


#init
current_state = getState(melody[0])
harmony = []
harmony.append(current_state)

# for each bar generate a chord
for bar in melody[1:]:

    # empty bars generated by split()
    if bar == '':
        continue

    current_state = getState(bar)

    # not doing this anymore
    '''
    # random (weighted) choice between the possible chords
    #prob = (1 - melody_w)*transition_matrix[current_state] + melody_w * note_state
    prob = note_state

    current_state = random.choice(np.argwhere(prob == np.amax(prob)).flatten().tolist())
    '''

    harmony.append(current_state)

# make it a string
harmony = [str(x) for x in harmony]
data = ''.join(lines[:2]) + '|'.join(harmony)

# write to file
with open(filename, 'w') as f:
    f.write(data)
